### 类

###### 基本思想：数据抽象和封装

**数据抽象**：依赖于接口和实现分离的编程（以及设计）技术

​					类的接口定义了用户所能执行的操作

​					类的实现则包括类的具体实现，如数据成员，负责接口实现的函数体以及定义在类内部的私有成员函数

**封装**：实现了类的接口和实现的分离，使得类的实现细节得以隐藏

#### this指针与成员函数

this可以看作是每个成员函数的隐式形参，由编译器默认传递

this指针是一个常量指针，不可以修改其指向

，顶层const

**常量成员函数** 底层const

#### 构造函数

构造函数不可以是const的，等构造函数完成了其过程，对象才能取得其常量属性

##### **默认构造函数** 

只有当类没有声明任何构造函数时，编译器才会生成默认构造函数

有成员对象没有默认构造函数时

类内初始值

```c++
= default 
```

##### 构造函数初始值列表

#### 拷贝、赋值和析构

编译器会生成默认版本

注意使用动态内存的成员变量

vector和string成员变量在使用默认版本时可以正常工作

#### 访问控制与封装

**封装的益处** 

1 确保用户代码不会无意间破坏对象的状态

2 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

##### 友元

友元的声明仅仅定义了访问的权限，而非声明。

#### 类的其他特性

##### 类成员在探

类型成员应该在使用之前就定义，这一点与其他成员不一样。

##### 内联函数

可以在类内外使用**inline**来显示的定义内联函数

##### 可变数据成员

**mutable**

##### 类内初始值

当我们提供一个类内初始值时，必须以符号=或者花括号表示

##### 返回*this的成员函数

修饰this的const时一个顶层const,意味着不能修改this的指向，但是通过this返回对象引用时，可以修改此对象中的数据

类的const成员函数会声明一个const type* const this指针，当这种函数返回对象引用时，则不能修改此对象中的数据

##### 类类型

**前向声明** **不完全类型**

类的成员类型不能时该类自己，意味着不能再类型声明一个该类自己的对象（不是指针和引用）

##### 友元再探

#### 类的作用域

##### 名字查找与类的作用域

类的定义分两步处理：

1 编译成员的声明

2 直到类全部可以见后才编译函数体

复习名字查找的规则：从类内到类外

#### 构造函数再探

##### 构造函数初始值列表

直接初始化，效率较高

可以对const 或者引用成员变量初始化

**成员初始化的顺序**与成员定义的顺序有关，与在初始值列表中的顺序无关

**默认实参与构造函数**如果一个构造函数为所有的参数都提供了默认实参，那它就是一个默认构造函数

##### 委托构造函数（c++11）

##### 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。

**默认初始化**

**值初始化**

最好提供一个默认构造函数。

##### 隐式的类类型转换

当类有只有一个参数的构造函数时，可以发生隐式类型转换

**只允许一步类类型转换**

类类型转换不是总有效

**抑制构造函数定义的隐式转换**

***explicity*** 构造函数只能用于直接初始化，且只能用于类内声明

##### 聚合类

##### 字面值常量类

#### 类的静态成员

独立于对象存在，不能在类的构造函数中定义，存在于程序整个生命周期中。

##### 静态成员的类内初始化

静态成员必须是constexpr的字面值常量类型，初始值也必须是常量表达式。（仅用于编译器作替换用）

最好在类外定义一下，可以不提供初始值

##### 静态数据成员可以用于某些场景，普通成员则不能

静态数据成员可以是不完全类型

静态数据成员可以作为默认实参

```c++
class Test
{
	public:
    	
    private:
    	static Test m_test;
    	Test* m_test2;
    	Test  m_test3; // error
}
```

