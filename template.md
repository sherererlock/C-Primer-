### 定义模板

#### 一 函数模板

 template<typename T> T& function(T& one, T& two){ return one;}

##### 实例化函数模板

​	使用具体的类型来实例化函数模板，编译器为用具体的类型替换T，从而生成函数模板的实bi例。

​	编译器可为函数模板推断出T的类型。

##### 模板类型参数

​	可以用class或者typename 声明

##### 非类型模板参数

​	表示一个值而非一种类型，用特定的类型名声明

​	template<int N> void function(){print(N);}

##### inline和constexpr

​	放在模板参数列表之后，返回类型之前

##### 编写与类型无关的代码

​	模板程序应该尽量减少对实参类型的要求，使得模板尽量的通用。

##### 模板编译

​	1 实例化模板的一个特定版本时，编译器才会生成代码

​	2 模板的头文件通常既需要包含声明也需要包含定义，也就是说模板的定义必须时可见的

#### 二 类模板

##### 定义类模板

​	template<typename T>

​	class Base

​		{ T& a; }

##### 实例化类模板

​	编译器不能为类模板推断出实参类型，声明时必须指定实参类型

​	Base<int> tmp;

##### 类模板的成员函数

###### 	声明与定义

​		可以定义在类模板的外部或者内部，在内部时，会被隐式声明为内联函数

###### 	实例化

​		如果一个成员函数没有被使用，则它不会被实例化。

​		特性的使用：即使某种类型不能完全符合模板操作的要求，我们也能使用该类型实例化类

#### 在类代码内简化类模板的使用

#### 类模板和友元

​	1 如果一个类包含一个非模板友元，则这个友元可以访问所有模板的实例

​	2 如果友元是模板

​			（1）一对一友好关系

​			（2）通用和特定的模板友好关系

​			（3）令模板自己的类型参数成为友元

#### 模板类型别名

#### 类模板和static成员

##### 	变量

​		有且只有一个定义

​		template<typename T>

​		size_t Foo<T>::ctr = 0

​		疑问：不能用实参类型声明static成员，因为无法定义。

##### 	函数

​		只有使用时才会被实例。

#### 三 模板参数

##### 模板实参与作用域

​	遵循普通作用域规则

​	不能重用模板参数名

##### 模板声明

​	模板声明必须包含模板参数，定义中的名字可以与声明不同

##### 使用类的类型成员

​	作用域运算符::

​		可以引用到类的静态成员

​		可以引用到类的类型成员

​	使用一个模板参数的类型成员时，可以用typename

​		typename T::value_type

##### 默认模板实参

###### 	函数模板

###### 	类模板

#### 四 成员模板

​	成员模板不能是虚函数

##### 普通类的成员模板

##### 类模板的成员模板

​	类模板和成员模板有各自独立的模板参数

​	template<typename T> class Blob{

​		template<typename IT> Blob(It& it);

​	}

​	template<typename T>

​	template<typename IT> 

​		Blob(It& it){}

##### 实例化与成员模板

#### 五 控制实例化

​	当模板被使用时，才会被实例化。

​	相同的模板实例会出现在多个对象文件中。

##### 显示实例化

​	extern template class Blob<string>; 声明，不会在当前文件中实例化；

​	template class Blob<string> ;定义，会导致实例化

##### 实例化定义会实例化所有类模板的成员

### 模板实参推断

​	从函数实参来确定模板实参的过程称为模板实参推断。

#### 一 类型转换与模板类型参数

​	只有两种转行能用于模板实参推断中

​	1 const转换：将一个非const的引用转换为const引用

​	2 数组或函数到指针的转换

​	其他类型，要么不能转换，要么生成一个新的模板实例

​	1	不能实现数组到引用的转换

​	2	父类和子类之间的相互转换

##### 使用相同模板参数类型的函数形参

​	由于只有上述类型转换可以在模板实参推断中使用，所以传递给这些形参的实参类型如果不匹配，调用就是错误的。

​	如int，long就不能在模板实参推断中进行正确的转换。

##### 正常类型转换应用于普通函数实参

#### 二 函数模板显示实参

​	在某些情况下，编译器无法推断模板实参类型。

​	在某些情况下，我们希望由用户控制模板实例化。

​	例，函数返回类型与模板参数列表中的类型都不相同时。

##### 指定显示模板实参

​	template<tyname T1, tyname T2, tyname T3>

​	T1 sum(T2, T3)

​	编译器无法推断T1的类型，故需要用户提供一个显示模板实参。

​    auto& value = sum<long long>(i,lng) // long long sum(int, long)

​	第一模板实参与第一个参数匹配，第二个实参与第二个参数匹配，以此类推。

​	尾部的显示模板实参可以忽略，而且前提时他们可以推断出来。

##### 正常类型转换用于显示指定的参数

​	template<typename T> compare(T value1, T value2);

​	long lng;

​	compare(lng, 1024) ;	//error，模板参数不匹配

​	compare<long>(lng, 1024); // compare(long, long);

#### 三 尾置返回类型和类型转换

​	无前置知识

#### 四 函数指针与实参推断

​	将函数模板当成一个函数指针传递或保存时会进行实参推断。

​	编译器会通过函数指针的类型来推断模板实参。

​	template<typename T>  int compare(const T&, const T&);

​	int (*f1)  (const int&, const int&) = compare;

​	如果不能从函数指针中确定模板实参，则会产生错误，此时要显示模板实参来消除错误。

​	例如:

```
void func(int(*)(const string& v1, const string& v2));
void func(int(*)(const int& v1, const int& v2));
func(compare);
```

#### 五 模板实参推断与引用

​	

​	